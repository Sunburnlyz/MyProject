# Project 4:  SM3的软件实现与优化

本项目从SM3的基本软件实现出发，对SM3的软件执行效率进行改进，之后验证length-extension attack，最后根据RFC6962构建Merkle树（10w叶子节点），并构建叶子的存在性证明和不存在性证明。



##  SM3算法简介
SM3是一个哈希函数，输入为任意长度消息 M ，输出是固定长度 256 位哈希值 H(M)

### 加轮常量
对block每一个元素都加上轮常量C。

### 填充（Padding）
消息M 被填充为长度是 512 的整数倍：

$M' = M \, \| \, 1 \, \| \, 0^k \, \| \, \text{len}(M)_{64}$

其中包括原消息M、1、多个0和M的64位长度

### 分组与消息扩展
将填充后的消息分为 \( n \) 个 512 位的块  $B_0, B_1, \dots, B_{n-1} $，每块划分为 16 个 32 位字 $ W_0, \dots, W_{15} $

扩展公式生成 68 个 $ W_j $和64 个扩展字$W'_j$.

### 压缩函数
之后对每个 512 位消息块$B_i$，进行 64 轮迭代压缩。

### 输出
所有消息块压缩完成后：
$H(M) = V_0 \oplus V_1 \oplus \dots \oplus V_n$

最终输出 256 位哈希值 \( H(M) \)。

## 优化方案
我们通过SIMD优化效率

- 消息扩展方面，我们对每一个 block 中的 512bit 消息，展开成 132 个 32bit word。
- 压缩函数：我们使用 SIMD 并行实现，将原来的压缩函数变成支持 AVX2 的 8-block 并行计算


##  长度扩展攻击
长度扩展攻击需要满足：

- 已知哈希值 H(m)，但不知道 m 的内容。

- 原始消息 m 末尾会进行标准填充

- 构造 $m || padding(m) || m'$，满足 $SM3(m || padding(m) || m') == H(m || m')$

## 构建Merkle树

Merkle 树是一种二叉哈希树，主要用于高效验证大量数据的完整性和一致性。它的核心思想是：

- 每个叶子节点存储数据的哈希值；

- 每个非叶子节点存储其子节点哈希值的组合哈希；

- 树根可以唯一确定整个数据集的哈希。

### 叶子存在性证明
从叶子哈希开始，逐层与兄弟节点合并，如果最后的结果和树的根节点相同，那么存在性证明完毕。