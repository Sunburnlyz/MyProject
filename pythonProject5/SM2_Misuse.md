
# SM2签名算法误用推导文档
签名算法可能会出现误用的场景，很多人可能对该情况造成的后果缺乏认知，因此我们对情景进行推导，并证明其可以会恢复出用户的私钥。

## 场景一：随机数 k 泄露

假设攻击者已知椭圆曲线的参数、用户的签名（r，s），随机数k。

签名公式：

```
s = (k - r * d) / (1 + d) mod n
```

两边乘以 `(1 + d)`：

```
s * (1 + d) = k - r * d
```

移项整理：

```
k - s = d * (r + s)
```

解出私钥：

```
d = (k - s) * inverse_mod(r + s, n) mod n
```

---

## 场景二：同一个用户对两条消息复用 k

攻击者知道两条消息 M1, M2 使用相同随机数 `k` 和私钥 `d`，得到签名 (r1, s1), (r2, s2)，此时攻击者可以恢复出用户的私钥。

签名公式：

```
s1 = (k - r1 * d) / (1 + d) mod n
s2 = (k - r2 * d) / (1 + d) mod n
```

两式相减：

```
s2 - s1 = (r1 - r2) * d / (1 + d)
```

拆分1+d并移项：

```
(s1 - s2 + r1 - r2) * d = s2 - s1
```

解出私钥：

```
d = (s2 - s1) * inverse_mod(s1 - s2 + r1 - r2, n)
```

---

## 场景三：不同用户在签名时重复使用同一个 k

两个用户 A 和 B 使用相同 `k` 对同一条消息签名：

- 用户 A 使用私钥 `dA`，得到 `(r1, s1)`
- 用户 B 使用私钥 `dB`，得到 `(r2, s2)`

此时如果A知道B和他用的同样的随机数k，那么这相当于随机数k泄露，A可以用类似场景一的公式求出B的私钥：



```
dB = (k - s2) * inverse_mod(r2 + s2, n) mod n
```

---

## 场景四：同一个 k, d 对同一消息分别使用 SM2 和 ECDSA 签名

假设使用私钥 `d` 和随机数 `k`：

- ECDSA 签名公式为：

```
s1 = (e1 + r1 * d) / k mod n
```


- SM2 签名公式为：

```
s2 = (k - r2 * d) / (1 + d) mod n
```


根据

```
d * r1 = k * s1 - e1 mod n
d * (s2 + r2) = k - s2 mod n
```

可以推出 d：

```
d = (s1 * s2 - e1) / (r1 - s1 * s2 - s1 * r2) mod n
```


---
